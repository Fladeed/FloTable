# Best Practices

Learn the recommended patterns and practices for using FloTable with Views effectively.

## Data Management

### Type Safety

Always define proper TypeScript interfaces for your data:

```tsx
// ✅ Good: Well-defined interface
interface Restaurant {
  id: string;
  name: string;
  cuisine: string;
  rating: number;
  status: 'open' | 'closed' | 'pending';
  location: {
    address: string;
    city: string;
    country: string;
  };
  createdAt: string;
  updatedAt: string;
}

// ❌ Bad: Using any
const columns: ProColumns<any>[] = [
  // ...
];
```

### Request Function Patterns

#### Error Handling

Always implement proper error handling:

```tsx
const handleRequest = async (params: any, sort: any, filter: any) => {
  try {
    const response = await fetch('/api/restaurants', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...params, ...filter.filters, sort }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();

    return {
      data: data.restaurants || [],
      success: true,
      total: data.total || 0,
    };
  } catch (error) {
    console.error('Failed to fetch restaurants:', error);
    return {
      data: [],
      success: false,
      total: 0,
    };
  }
};
```

#### Loading States

Handle loading states properly:

```tsx
const [loading, setLoading] = useState(false);

const handleRequest = async (params: any, sort: any, filter: any) => {
  setLoading(true);
  try {
    // ... fetch logic
    return result;
  } finally {
    setLoading(false);
  }
};

<TableWithViews
  loading={loading}
  request={handleRequest}
  // ... other props
/>
```

## Performance

### Memoization

Memoize expensive computations:

```tsx
import { useMemo } from 'react';

const RestaurantTable = () => {
  const columns = useMemo(() => [
    {
      title: 'Name',
      dataIndex: 'name',
      key: 'name',
      render: (text, record) => (
        <Link to={`/restaurants/${record.id}`}>
          {text}
        </Link>
      ),
    },
    {
      title: 'Rating',
      dataIndex: 'rating',
      key: 'rating',
      render: (rating) => (
        <Rate disabled defaultValue={rating} />
      ),
    },
    // ... more columns
  ], []);

  const views = useMemo(() => [
    {
      key: 'all',
      label: 'All Restaurants',
      shortLabel: 'All',
      query: '',
      filters: {},
    },
    // ... more views
  ], []);

  return (
    <TableWithViews
      columns={columns}
      views={views}
      // ... other props
    />
  );
};
```

### Debounced Search

Implement search debouncing to reduce API calls:

```tsx
import { useCallback } from 'react';
import { debounce } from 'lodash';

const debouncedRefresh = useCallback(
  debounce((actionRef) => {
    actionRef.current?.reload();
  }, 300),
  []
);

const handleSearch = (value: string) => {
  setSearchTerm(value);
  debouncedRefresh(actionRef);
};
```

## User Experience

### Responsive Design

Design for mobile-first:

```tsx
const { isMobile } = useIsMobile();

const columns: ProColumns<Restaurant>[] = [
  {
    title: 'Restaurant',
    dataIndex: 'name',
    key: 'name',
    width: isMobile ? 200 : 250,
    render: (text, record) => (
      <div>
        <div className="font-medium">{text}</div>
        {isMobile && (
          <div className="text-sm text-gray-500">
            {record.cuisine} • {record.location.city}
          </div>
        )}
      </div>
    ),
  },
  // Show cuisine and location separately on desktop
  ...(!isMobile ? [
    {
      title: 'Cuisine',
      dataIndex: 'cuisine',
      key: 'cuisine',
      width: 120,
    },
    {
      title: 'Location',
      dataIndex: ['location', 'city'],
      key: 'location',
      width: 150,
    },
  ] : []),
  // Always show rating and status
  {
    title: 'Rating',
    dataIndex: 'rating',
    key: 'rating',
    width: isMobile ? 80 : 120,
    render: (rating) => (
      <Rate disabled defaultValue={rating} style={{ fontSize: isMobile ? 12 : 14 }} />
    ),
  },
];
```

### Accessible Actions

Make actions accessible:

```tsx
const actions = [
  {
    key: 'export',
    label: 'Export Data',
    icon: <DownloadOutlined />,
    onClick: handleExport,
    'aria-label': 'Export restaurant data to CSV',
  },
  {
    key: 'refresh',
    label: 'Refresh',
    icon: <ReloadOutlined />,
    onClick: handleRefresh,
    'aria-label': 'Refresh restaurant list',
  },
];
```

### Meaningful Empty States

Provide helpful empty states:

```tsx
const getEmptyComponent = (activeView: string) => {
  const emptyStates = {
    all: {
      title: 'No restaurants found',
      description: 'Start by adding your first restaurant',
      action: (
        <Button type="primary" icon={<PlusOutlined />}>
          Add Restaurant
        </Button>
      ),
    },
    open: {
      title: 'No open restaurants',
      description: 'All restaurants are currently closed',
      action: null,
    },
    pending: {
      title: 'No pending approvals',
      description: 'All restaurants have been reviewed',
      action: null,
    },
  };

  const state = emptyStates[activeView] || emptyStates.all;

  return (
    <Empty
      description={
        <div>
          <div className="text-lg font-medium">{state.title}</div>
          <div className="text-gray-500">{state.description}</div>
        </div>
      }
    >
      {state.action}
    </Empty>
  );
};
```

## Code Organization

### Component Composition

Break down complex tables into smaller components:

```tsx
// components/RestaurantTable/columns.tsx
export const createRestaurantColumns = (isMobile: boolean): ProColumns<Restaurant>[] => [
  // ... column definitions
];

// components/RestaurantTable/views.tsx
export const restaurantViews = [
  // ... view definitions
];

// components/RestaurantTable/actions.tsx
export const createRestaurantActions = (onExport: () => void) => [
  // ... action definitions
];

// components/RestaurantTable/index.tsx
export const RestaurantTable = () => {
  const { isMobile } = useIsMobile();
  
  const columns = useMemo(() => createRestaurantColumns(isMobile), [isMobile]);
  const actions = useMemo(() => createRestaurantActions(handleExport), [handleExport]);

  return (
    <TableWithViews
      columns={columns}
      views={restaurantViews}
      actions={actions}
      // ... other props
    />
  );
};
```

### Custom Hooks

Extract table logic into custom hooks:

```tsx
// hooks/useRestaurantTable.ts
export const useRestaurantTable = () => {
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState<Restaurant[]>([]);
  const [total, setTotal] = useState(0);

  const handleRequest = useCallback(async (params: any, sort: any, filter: any) => {
    setLoading(true);
    try {
      const response = await restaurantAPI.getRestaurants({
        ...params,
        ...filter.filters,
        sort,
      });

      setData(response.data);
      setTotal(response.total);

      return {
        data: response.data,
        success: true,
        total: response.total,
      };
    } catch (error) {
      console.error('Failed to fetch restaurants:', error);
      return {
        data: [],
        success: false,
        total: 0,
      };
    } finally {
      setLoading(false);
    }
  }, []);

  const handleExport = useCallback(() => {
    // Export logic
  }, [data]);

  return {
    loading,
    data,
    total,
    handleRequest,
    handleExport,
  };
};
```

## Testing

### Unit Testing

Test your table components:

```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { RestaurantTable } from './RestaurantTable';

describe('RestaurantTable', () => {
  it('renders restaurant data correctly', async () => {
    render(<RestaurantTable />);
    
    // Wait for data to load
    await screen.findByText('Pizza Palace');
    
    expect(screen.getByText('Italian')).toBeInTheDocument();
    expect(screen.getByText('New York')).toBeInTheDocument();
  });

  it('filters by status correctly', async () => {
    render(<RestaurantTable />);
    
    // Click on "Open" view
    fireEvent.click(screen.getByText('Open Restaurants'));
    
    // Should only show open restaurants
    await screen.findByText('Pizza Palace');
    expect(screen.queryByText('Closed Restaurant')).not.toBeInTheDocument();
  });

  it('handles export action', () => {
    const mockExport = jest.fn();
    render(<RestaurantTable onExport={mockExport} />);
    
    fireEvent.click(screen.getByLabelText('Export restaurant data to CSV'));
    expect(mockExport).toHaveBeenCalled();
  });
});
```

### Integration Testing

Test the complete table workflow:

```tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { server } from '../mocks/server';
import { RestaurantTable } from './RestaurantTable';

describe('RestaurantTable Integration', () => {
  beforeAll(() => server.listen());
  afterEach(() => server.resetHandlers());
  afterAll(() => server.close());

  it('loads and displays restaurant data', async () => {
    render(<RestaurantTable />);
    
    // Wait for loading to complete
    await waitFor(() => {
      expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
    });
    
    // Check if data is displayed
    expect(screen.getByText('Pizza Palace')).toBeInTheDocument();
    expect(screen.getByText('Sushi World')).toBeInTheDocument();
  });

  it('handles API errors gracefully', async () => {
    // Mock API error
    server.use(
      rest.post('/api/restaurants', (req, res, ctx) => {
        return res(ctx.status(500), ctx.json({ error: 'Server error' }));
      })
    );

    render(<RestaurantTable />);
    
    await waitFor(() => {
      expect(screen.getByText('Failed to load data')).toBeInTheDocument();
    });
  });
});
```

## Security

### Input Sanitization

Always sanitize user inputs:

```tsx
import { escapeHtml } from '../utils/security';

const columns: ProColumns<Restaurant>[] = [
  {
    title: 'Name',
    dataIndex: 'name',
    key: 'name',
    render: (text) => escapeHtml(text), // Prevent XSS
  },
];
```

### API Security

Implement proper API security:

```tsx
const handleRequest = async (params: any, sort: any, filter: any) => {
  // Validate and sanitize inputs
  const sanitizedParams = {
    current: Math.max(1, parseInt(params.current) || 1),
    pageSize: Math.min(100, Math.max(10, parseInt(params.pageSize) || 20)),
    keyword: params.keyword?.replace(/[<>]/g, ''), // Basic sanitization
  };

  const response = await fetch('/api/restaurants', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getAuthToken()}`,
    },
    body: JSON.stringify(sanitizedParams),
  });

  // ... handle response
};
```